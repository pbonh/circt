// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: circt-opt %s --convert-llhd-to-llvm --split-input-file | FileCheck %s

// CHECK-LABEL:   llvm.func @convert_insert_slice(
// CHECK-SAME:                                    %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                    %[[VAL_1:.*]]: i10,
// CHECK-SAME:                                    %[[VAL_2:.*]]: !llvm.array<4 x i5>,
// CHECK-SAME:                                    %[[VAL_3:.*]]: !llvm.array<2 x i5>) {
// CHECK:           %[[VAL_4:.*]] = llvm.mlir.constant(0 : index) : i64
// CHECK:           %[[VAL_5:.*]] = llvm.trunc %[[VAL_4]] : i64 to i32
// CHECK:           %[[VAL_6:.*]] = llvm.mlir.constant(1023 : i32) : i32
// CHECK:           %[[VAL_7:.*]] = llvm.mlir.constant(-1024 : i32) : i32
// CHECK:           %[[VAL_8:.*]] = llvm.zext %[[VAL_1]] : i10 to i32
// CHECK:           %[[VAL_9:.*]] = llvm.shl %[[VAL_8]], %[[VAL_5]] : i32
// CHECK:           %[[VAL_10:.*]] = llvm.or %[[VAL_9]], %[[VAL_7]] : i32
// CHECK:           %[[VAL_11:.*]] = llvm.or %[[VAL_0]], %[[VAL_6]] : i32
// CHECK:           %[[VAL_12:.*]] = llvm.and %[[VAL_11]], %[[VAL_10]] : i32
// CHECK:           %[[VAL_13:.*]] = llvm.extractvalue %[[VAL_3]][0 : i32] : !llvm.array<2 x i5>
// CHECK:           %[[VAL_14:.*]] = llvm.insertvalue %[[VAL_13]], %[[VAL_2]][1 : i32] : !llvm.array<4 x i5>
// CHECK:           %[[VAL_15:.*]] = llvm.extractvalue %[[VAL_3]][1 : i32] : !llvm.array<2 x i5>
// CHECK:           %[[VAL_16:.*]] = llvm.insertvalue %[[VAL_15]], %[[VAL_14]][2 : i32] : !llvm.array<4 x i5>
// CHECK:           llvm.return
// CHECK:         }
func @convert_insert_slice(%int : i32, %iSlice : i10, %arr : !hw.array<4xi5>, %arrSlice : !hw.array<2xi5>) {
  %0 = llhd.insert_slice %int, %iSlice, 0 : i32, i10
  %1 = llhd.insert_slice %arr, %arrSlice, 1 : !hw.array<4xi5>, !hw.array<2xi5>

  return
}

// CHECK-LABEL:   llvm.func @convert_insert_element(
// CHECK-SAME:                                      %[[VAL_0:.*]]: i5,
// CHECK-SAME:                                      %[[VAL_1:.*]]: !llvm.array<4 x i5>,
// CHECK-SAME:                                      %[[VAL_2:.*]]: !llvm.struct<(i6, i5, i4)>) {
// CHECK:           %[[VAL_3:.*]] = llvm.insertvalue %[[VAL_0]], %[[VAL_1]][0 : index] : !llvm.array<4 x i5>
// CHECK:           %[[VAL_4:.*]] = llvm.insertvalue %[[VAL_0]], %[[VAL_2]][1 : index] : !llvm.struct<(i6, i5, i4)>
// CHECK:           llvm.return
// CHECK:         }
func @convert_insert_element(%int : i5, %arr : !hw.array<4xi5>, %tup : !hw.struct<foo: i4, bar: i5, baz: i6>) {
  %0 = llhd.insert_element %arr, %int, 0 : !hw.array<4xi5>, i5
  %1 = llhd.insert_element %tup, %int, 1 : !hw.struct<foo: i4, bar: i5, baz: i6>, i5

  return
}
